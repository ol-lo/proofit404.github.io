* I need to talk about
** Trace mode
** postmortem mode
** -c continue mode
* TODO How the hell "up" and "down" and "!" works?!
* TODO What the hell is "debug" and "jump"?
* TODO How "interact" command was implemented?
* TODO Main implementation principle
** set_trace implementation
*** what does "frame.f_trace = self.trace_dispatch" mean?
*** sys.settrace implementation
* TODO How commands were implemented
** How "next" command works?
** How "until" command works?
** How "return" command works?
** How "list" command works?
** How "w" command works?
   self.get_stack walks from current frame by link f.f_back collecting
   all frames up until bottom frame.
** How "continue" to next breakpoint works
   If there is no breakpoints any more "set_continue" just call
   sys.settrace(None) which means normal execution.
* TODO What is linecache module?
* TODO What is postmortem?
** Does it operate on traceback somehow?
** Does it work if traceback was affected like in Jinja2
* TODO How generators and coroutines go inside?
** tornado "yield" example
** asyncio "yield from" and "await" example
* Style notes
** We form this as XKCD styled story
** With each chapter our character becomes older and beardy
** Moral
   At the beginning of the story our young programmer without debugger
   was derided by old beardy C programmer, how have Gdb.  At the last
   slide our grown up old Python programmer comes to the next <no name
   lang> programmer to show how cool Pdb is and this fresh <no name
   lang> isn't cool because of missed debugger.
* TODO How to work with Threads and multiprocessing?
* TODO How inspect module is used here?
** How inspect.findsource works?
* TODO What is about ": " prompt?
* TODO How can I skip execution to the end of huge dict literal
  Does until do this?
* Set trace
  Looks like trace function doesn't applies to the nested function
  calls.  We need to return "local" trace function (or nested tracer)
  explicitly.

  Does trace function corresponds to the scoping rules in python?
  Describe what is scoping in python, when we speak about locals.
* TODO What is threading.set_trace function?
* TODO exceptions inside the trace function
* TODO what "function call" actually is?
* TODO Draw virtual machine state in the pictures
* TODO How to ignore function calls inside trace function itself?
  Otherwise we will trace tracer itself.  What a recursive world.
* TODO Structure of the frame object
* TODO Describe the difference between tracers and profilers
* Story line
** Introduction
   - I'm undependable developer, and I'm totally useless without debugger.
   - I'm going to tell you a story about programmer Jimmy.
** Prologue
   - Jimmy writes programs in Python
   - Jimmy uses print statements to debug his programs
   - Jimmy friends uses C programming language
   - There are a lot of debugging tools for C programming language
   - For example, gdb, valgrind, etc.
   - Jimmy lives in a world with where pdb and profile modules aren't
     written yet.
   - His friend making fun of Jimmy, because poor tooling kills
     productivity.
   - Jimmy decides to write this tools himself.
** Chapter 1: Trace function.
   - To write debugger we need a way to alter python bytecode
     execution.
   - To do that Jimmy needs to understand what bytecode actually is.
     And how CPython actually execute it.
   - Jimmy digs into "*.pyc" files sturcture.
   - Jimmy digs into dis module.
   - Jimmy digs into definitions of the code objects.
   - Jimmy digs into definitions of the frame objects.
     + Especially how globals and locals are stored.
   - Jimmy digs into interpreter Tic definition.
   - Jimmy digs into main loop execution.
     + Probably with code examples in the C programming language.
   - Jimmy implements set_trace function
     + Detailed explanation how it changes main loop behavior.
** Chapter 2: Pdb.
   - Jimmy has program which fails constantly with some input.
   - Jimmy writes usual Pdb functionality using set_trace.
   - Jimmy digs into readline library.
   - It includes pdb.set_trace and interactive commands.
** Chapter 3: Postmortem.
   - Jimmy has program which fails randomly after some unknown event.
   - Jimmy doesn't know anymore where to put pdb.set_trace call.
   - Jimmy needs the ability to jump into pdb right after exception
     happens.
   - Jimmy needs digs into definition of the exception (traceback)
     object.
   - Jimmy writes postmortem debugger hook
** Chapter 4: Multiprocessing.
   - Jimmy has even more complex situation.
   - Multi-process program randomly loose connection to database.
   - Jimmy decides to white improved debugger version (named Manhole
     and Hunter).
   - Jimmy digs into definitions of the fork and pty_fork.
   - Jimmy digs into socat (telnet alternative)
     + Mention readline from previous chapters.
** Chapter 5: Convenience.
   - Jimmy want nice autocompletion in the Pdb prompt.
   - Jimmy digs into ipython introspection possibilities.
   - Jimmy writes ipdb.
** Chapter 6: Time travel.
   - Jimmy start to use pypy interpreter.
   - Jimmy digs into its tracer dump.
   - Jimmy writes RevDB to travel backward in time.
** Epilogue.
   - Now Jimmy has awesome debugging tools and can solve issues easily
     + I know lisp, meditation xkcd.
   - Jimmy is really happy with this tools.
     + Anti-gravity xkcd.
   - Jimmy met Tommy.
   - Tommy really like <another> programming language.
   - <another> programming language doesn't have debugging tools.
   - Instead of being a jerk, Jimmy decides to help Tommy.
   - He gives him a list of useful links to read about python
     internals and debuggers, so Tommy can find inspiration in this
     topic.
     + https://pymotw.com/2/sys/tracing.html
     + http://cs263-technology-tutorial.readthedocs.io/en/latest/
   - Jimmy hopes it was interesting journey and I ready to answer your
     questions about this path.
