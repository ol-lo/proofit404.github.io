<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="css/reveal.css"><link rel="stylesheet" type="text/css" href="css/theme/white.css"><link rel="stylesheet" type="text/css" href="lib/css/github-gist.min.css"><link rel="stylesheet" type="text/css" href="css/customize.css"><title>Django Channels</title><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );</script></head><body><div class="reveal"><div class="slides"><section><h1>Django Channels</h1><h2>Artem Malyshev</h2><h3>@proofit404</h3></section><section><h1>Bring Django</h1><h1>to the async</h1><h1>networking</h1><aside class="notes"><p>What is the problem?</p><p>How it solves it?</p><p>What it is supposed for?</p><p>What it is <b>not</b> supposed for?</p></aside></section><section><h3>but we are already there</h3><ul><li>twisted</li><li>eventlet</li><li>gevent</li><li>tornado</li><li>asyncio</li></ul><aside class="notes"><p>Why the hell yet another async framework?</p></aside></section><section><h1>And django</h1><h1>is sync in</h1><h1>its core</h1><aside class="notes"><p>ORM by design</p><p>Tons of apps written this way</p></aside></section><section><h2>WSGI</h2><pre><code class="hljs python">def app(environ, callback):

    status, headers = '200 OK', []
    callback(status, headers)
    return ['Hello world!\n']</code></pre><aside class="notes"><p>Request - response</p><p>Middlewares</p></aside></section><section data-background="pic/http11.png" data-background-size="contain"><br><aside class="notes"><p>fire up django</p><p>handle request</p><p>return response</p><p>wait</p></aside></section><section><h3>OK, but it is</h3><h1>2016</h1><h2>dude</h2><aside class="notes"><p>user wants more</p></aside></section><section><h2>Progressive Web Apps</h2><ul><li>interactive communication</li><li>responsive design</li><li>push notifications</li><li>works offline</li></ul><aside class="notes"><p>Backend channels a lot too</p></aside></section><section data-background="pic/http2.png" data-background-size="contain"><br><aside class="notes"><p>accept request</p><p>send <b>few</b> responses</p><p>or <b>skip</b> response</p></aside></section><section><h2>It's all different</h2><h3>persistent</h3><h3>stateful</h3><h3>connections</h3><aside class="notes"><p>long-lived</p></aside></section><section><img src="pic/django-channels.png"><aside class="notes"><p>This is the problem django channels solves</p></aside></section><section><img class="face-photo photo-corner" src="pic/andrewgodwin.jpg"><aside class="notes"><p>machine gun</p><p>south / migrations</p></aside></section><section data-background="pic/infrastructure.png" data-background-size="contain"><br><aside class="notes"><p>daphne</p><p>redis, ipc, memory</p></aside></section><section><h1>ASGI</h1></section><section><h2>ASGI is</h2><p>a standard interface between</p><p class="fragment">network protocol servers</p><p class="fragment">and Python applications</p></section><section><h1>Channel</h1></section><section><h2>Channel is</h2><p>an ordered,</p><p class="fragment">first-in first-out queue</p><p class="fragment">with message expiry</p><p class="fragment">and at-most-once delivery</p><p class="fragment">to only one listener at a time</p></section><section><h1>Consumers</h1></section><section><h2>Accept websocket message</h2><pre><code class="hljs python">def ws_message(message):

    message.reply_channel.send({
        "text": message.content['text'],
    })</code></pre><aside class="notes"><p>It's like <b>view</b> function</p></aside></section><section><h2>Routing</h2><pre><code class="hljs python">from channels.routing import route
from myapp.consumers import ws_message

channel_routing = [
    route("websocket.receive", ws_message),
]</code></pre><aside class="notes"><p>there is many predefined channels</p><ul><li><b>http.*</b> for long polling</li><li><b>websockets.*</b></li></ul></aside></section><section><h2>Settings</h2><pre><code class="hljs python">CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "asgiref.inmemory",
        "ROUTING": "myproject.routing",
    },
}</code></pre><aside class="notes"><p>It is like <b>DBRouter</b></p></aside></section><section><h2>ASGI app</h2><pre><code class="hljs python">import os
from channels.asgi import get_channel_layer

os.environ.setdefault(
    "DJANGO_SETTINGS_MODULE",
    "myproject.settings",
)

channel_layer = get_channel_layer()</code></pre></section><section><h2>Deploy</h2><pre><code class="hljs bash">$ gunicorn myproject.wsgi</code></pre><pre><code class="hljs bash">$ daphne myproject.asgi:channel_layer</code></pre><pre><code class="hljs bash">$ django-admin runworker</code></pre></section><section><h1>Redis Layer</h1></section><section><h2>Redis Layer</h2><h3>BLPOP</h3><h3 class="fragment">Sinc on workers</h3><h3 class="fragment">Async on daphne</h3><h3 class="fragment">msgpack</h3><aside class="notes"><p><b>recieve</b> technique like Celery or RQ</p><p><b>twisted</b> friendly with connection <b>pools</b></p></aside></section><section><h1>Questions?</h1></section></div></div><script src="lib/js/head.min.js"></script><script src="js/reveal.js"></script><script src="lib/js/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script>Reveal.initialize({
    controls: false,
    progress: false,
    slideNumber: true,
    history: true,
    transition: 'none',
    dependencies: [
        { src: 'plugin/notes/notes.js', async: true }
    ]
});</script></body></html>