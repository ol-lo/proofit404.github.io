<!DOCTYPE html><html><head><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="css/reveal.css"><link rel="stylesheet" type="text/css" href="css/theme/white.css"><link rel="stylesheet" type="text/css" href="lib/css/github-gist.min.css"><link rel="stylesheet" type="text/css" href="css/customize.css"><title>Django Channels</title><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );</script></head><body><div class="reveal"><div class="slides"><section><h1>Django Channels</h1><h2>Artem Malyshev</h2><h3>@proofit404</h3></section><section><h1>Bring Django</h1><h1>to the async</h1><h1>networking</h1><aside class="notes"><p>What is the problem?</p><p>How it solves it?</p><p>What it is supposed for?</p><p>What it is <b>not</b> supposed for?</p></aside></section><section><h3>but we are already there</h3><ul><li>twisted</li><li>eventlet</li><li>gevent</li><li>tornado</li><li>asyncio</li></ul><aside class="notes"><p>Why the hell yet another async framework?</p></aside></section><section><h1>And django</h1><h1>is sync in</h1><h1>its core</h1><aside class="notes"><p>ORM by design</p><p>Tons of apps written this way</p></aside></section><section><h2>WSGI</h2><pre><code class="hljs python">def app(environ, callback):

    status, headers = '200 OK', []
    callback(status, headers)
    return ['Hello world!\n']</code></pre><aside class="notes"><p>Request - response</p><p>Middlewares</p></aside></section><section data-background="pic/http11.png" data-background-size="contain"><br><aside class="notes"><p>fire up django</p><p>handle request</p><p>return response</p><p>wait</p></aside></section><section><h3>OK, but it is</h3><h1>2016</h1><h2>dude</h2><aside class="notes"><p>user wants more</p></aside></section><section><h2>Progressive Web Apps</h2><ul><li>interactive communication</li><li>responsive design</li><li>push notifications</li><li>works offline</li></ul><aside class="notes"><p>Backend channels a lot too</p></aside></section><section data-background="pic/http2.png" data-background-size="contain"><br><aside class="notes"><p>accept request</p><p>send <b>few</b> responses</p><p>or <b>skip</b> response</p></aside></section><section><h2>It's all different</h2><h3>persistent</h3><h3>stateful</h3><h3>connections</h3><aside class="notes"><p>long-lived</p></aside></section><section><img src="pic/django-channels.png"><aside class="notes"><p>This is the problem we solves</p><p>No more one thread per one connection</p></aside></section><section><img class="face-photo photo-corner" src="pic/andrewgodwin.jpg"><aside class="notes"><p>machine gun</p><p>south / migrations</p></aside></section><section data-background="pic/infrastructure.png" data-background-size="contain"><br><aside class="notes"><p>daphne</p><p>redis, ipc, memory</p></aside></section><section><img class="face-photo" src="pic/twisted.png"><img class="face-photo" src="pic/redis.png"></section><section><h1>ASGI</h1></section><section><h2>ASGI is</h2><p>a standard interface between</p><p class="fragment">network protocol servers</p><p class="fragment">and Python applications</p></section><section><h1>Channel</h1></section><section><h2>Channel is</h2><p>an ordered,</p><p class="fragment">first-in first-out queue</p><p class="fragment">with message expiry</p><p class="fragment">and at-most-once delivery</p><p class="fragment">to only one listener at a time</p></section><section><h1>Consumers</h1></section><section><h2>Accept websocket message</h2><pre><code class="hljs python">def ws_message(message):

    message.reply_channel.send({
        "text": message.content['text'],
    })</code></pre><aside class="notes"><p>It's like <b>view</b> function</p></aside></section><section><h2>Routing</h2><pre><code class="hljs python">from channels.routing import route
from myapp.consumers import ws_message

channel_routing = [
    route("websocket.receive", ws_message),
]</code></pre><aside class="notes"><p>there is many predefined channels</p><ul><li><b>http.*</b> for long polling</li><li><b>websockets.*</b></li></ul></aside></section><section><h2>Settings</h2><pre><code class="hljs python">CHANNEL_LAYERS = {
    "default": {
        "BACKEND": "asgiref.inmemory",
        "ROUTING": "myproject.routing",
    },
}</code></pre><aside class="notes"><p>It is like <b>DBRouter</b></p></aside></section><section><h2>ASGI app</h2><pre><code class="hljs python">import os
from channels.asgi import get_channel_layer

os.environ.setdefault(
    "DJANGO_SETTINGS_MODULE",
    "myproject.settings",
)

channel_layer = get_channel_layer()</code></pre></section><section><h2>Deploy</h2><pre><code class="hljs bash">$ gunicorn myproject.wsgi</code></pre><pre><code class="hljs bash">$ daphne myproject.asgi:channel_layer</code></pre><pre><code class="hljs bash">$ django-admin runworker</code></pre></section><section><h1>Reply channel</h1></section><section data-background="pic/reply_channel.png" data-background-size="contain"><br><aside class="notes"><p>Unique for client connection</p><p>Stored in message</p></aside></section><section><h1>Groups</h1><aside class="notes"><p>Implemented by layer</p></aside></section><section><h2>Consumers</h2><pre><code class="hljs python">from channels import Group

def ws_connect(message):
    Group("chat").add(message.reply_channel)

def ws_disconnect(message):
    Group("chat").discard(message.reply_channel)

def ws_message(message):
    Group("chat").send({
        "text": message.content['text'],
    })</code></pre></section><section><h2>Routing</h2><pre><code class="hljs python">from channels.routing import route
from myapp.consumers import *

channel_routing = [
    route("websocket.connect", ws_connect),
    route("websocket.disconnect", ws_disconnect),
    route("websocket.receive", ws_message),
]</code></pre></section><section><h1>Generic consumers</h1></section><section><h2>Base consumer</h2><pre><code class="hljs python">from channels.generic import BaseConsumer

class MyConsumer(BaseConsumer):

    method_mapping = {
        "channel.name.here": "method_name",
    }

    def method_name(self, message, **kwargs):
        pass</code></pre></section><section><h2>Websocket consumer</h2><pre><code class="hljs python">from channels.generic import WebsocketConsumer

class MyConsumer(WebsocketConsumer):

    def connection_groups(self):
        return ["chat"]

    def connect(self, message):
        pass

    def receive(self, text=None, bytes=None):
        self.send(text=text, bytes=bytes)</code></pre><aside class="notes"><p><b>self.send</b> will send to the group</p><p><b>JSON</b> variant as well</p></aside></section><section><h2>Routing</h2><pre><code class="hljs python">from channels import route_class
from myapp import consumers

channel_routing = [
    route_class(consumers.MyConsumer),
]</code></pre><aside class="notes"><p>base will take from its mapping</p></aside></section><section><h1>Routing</h1><ul><li>Includes</li><li>how kwargs works</li></ul></section><section><h1>Multiplexing</h1></section><section><h1>Data binding</h1></section><section><h1>Message order</h1></section><section><h1>Redis Layer</h1></section><section><h2>Redis Layer</h2><h3>BLPOP</h3><h3 class="fragment">Sinc on workers</h3><h3 class="fragment">Async on daphne</h3><h3 class="fragment">msgpack</h3><aside class="notes"><p><b>recieve</b> technique like Celery or RQ</p><p><b>twisted</b> friendly with connection <b>pools</b></p></aside></section><section><h2>Channel implementation</h2><pre><code class="hljs">>>> FIXME!!!</code></pre></section><section><h2>Group implementation</h2><pre><code class="hljs">>>> FIXME!!!</code></pre></section><section><h1>Questions?</h1></section></div></div><script src="lib/js/head.min.js"></script><script src="js/reveal.js"></script><script src="lib/js/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script>Reveal.initialize({
    controls: false,
    progress: false,
    slideNumber: true,
    history: true,
    transition: 'none',
    dependencies: [
        { src: 'plugin/notes/notes.js', async: true }
    ]
});</script></body></html>