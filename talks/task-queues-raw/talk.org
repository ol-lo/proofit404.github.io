* TODO How global pub/sub work in the redis cluster?

* TODO AMQP properties?

* TODO What AMQP QoS, Channel and Transport stands for?
  See kombu.transport.virtual

* TODO What redis sentinel is?

* Redis broker implementation

** Name of queue equals name of list in the redis

** Whole message serialized and pushed in it

** It has properties field with members correlated with AMQP message properties

** It also has body field containing base64 encoded JSON byte string corresponding to AMQP message payload

   #+BEGIN_SRC python :session Python
     import base64
     x = 'eyJ1dGMiOiB0cnVlLCAiY2FsbGJhY2tzIjogbnVsbCwgInRhc2tzZXQiOiBudWxsLCAidGltZWxpbWl0IjogW251bGwsIG51bGxdLCAiY2hvcmQiOiBudWxsLCAiYXJncyI6IFsxLCAyXSwgImV4cGlyZXMiOiBudWxsLCAidGFzayI6ICJhcHAuYWRkIiwgImt3YXJncyI6IHt9LCAiZXJyYmFja3MiOiBudWxsLCAiaWQiOiAiN2M3MTlkN2YtOGU3NC00N2YzLTk0ODktODU5MTc3MzZiYzgyIiwgInJldHJpZXMiOiAwLCAiZXRhIjogbnVsbH0='
     base64.decodebytes(x.encode())
   #+END_SRC

   #+RESULTS:
   : b'{"utc": true, "callbacks": null, "taskset": null, "timelimit": [null, null], "chord": null, "args": [1, 2], "expires": null, "task": "app.add", "kwargs": {}, "errbacks": null, "id": "7c719d7f-8e74-47f3-9489-85917736bc82", "retries": 0, "eta": null}'

** If all serialization settings changed to pickle it still contains JSON document with body field in base64 string

   #+BEGIN_SRC python :session Python
     import base64
     x = 'gAJ9cQAoWAIAAABpZHEBWCQAAAAyNWY2ZWI0Ny1hZjgyLTQ0ZmYtYmY3Yy1kM2YzMjc0NDJjODdxAlgDAAAAdXRjcQOIWAcAAABleHBpcmVzcQROWAMAAABldGFxBU5YBQAAAGNob3JkcQZOWAQAAAB0YXNrcQdYBwAAAGFwcC5hZGRxCFgHAAAAdGFza3NldHEJTlgGAAAAa3dhcmdzcQp9cQtYBAAAAGFyZ3NxDEsBSwKGcQ1YCAAAAGVycmJhY2tzcQ5OWAkAAAB0aW1lbGltaXRxD05OhnEQWAcAAAByZXRyaWVzcRFLAFgJAAAAY2FsbGJhY2tzcRJOdS4='
     base64.decodebytes(x.encode())
   #+END_SRC

   #+RESULTS:
   : b'\x80\x02}q\x00(X\x02\x00\x00\x00idq\x01X$\x00\x00\x0025f6eb47-af82-44ff-bf7c-d3f327442c87q\x02X\x03\x00\x00\x00utcq\x03\x88X\x07\x00\x00\x00expiresq\x04NX\x03\x00\x00\x00etaq\x05NX\x05\x00\x00\x00chordq\x06NX\x04\x00\x00\x00taskq\x07X\x07\x00\x00\x00app.addq\x08X\x07\x00\x00\x00tasksetq\tNX\x06\x00\x00\x00kwargsq\n}q\x0bX\x04\x00\x00\x00argsq\x0cK\x01K\x02\x86q\rX\x08\x00\x00\x00errbacksq\x0eNX\t\x00\x00\x00timelimitq\x0fNN\x86q\x10X\x07\x00\x00\x00retriesq\x11K\x00X\t\x00\x00\x00callbacksq\x12Nu.'

** As we can see its same payload stored as pickle string

   #+BEGIN_SRC python :session Python
     import pickle
     pickle.loads(b'\x80\x02}q\x00(X\x02\x00\x00\x00idq\x01X$\x00\x00\x0025f6eb47-af82-44ff-bf7c-d3f327442c87q\x02X\x03\x00\x00\x00utcq\x03\x88X\x07\x00\x00\x00expiresq\x04NX\x03\x00\x00\x00etaq\x05NX\x05\x00\x00\x00chordq\x06NX\x04\x00\x00\x00taskq\x07X\x07\x00\x00\x00app.addq\x08X\x07\x00\x00\x00tasksetq\tNX\x06\x00\x00\x00kwargsq\n}q\x0bX\x04\x00\x00\x00argsq\x0cK\x01K\x02\x86q\rX\x08\x00\x00\x00errbacksq\x0eNX\t\x00\x00\x00timelimitq\x0fNN\x86q\x10X\x07\x00\x00\x00retriesq\x11K\x00X\t\x00\x00\x00callbacksq\x12Nu.')
   #+END_SRC

   #+RESULTS:
   | chord | : | hline | timelimit | : | (None None) | args | : | (1 2) | callbacks | : | hline | kwargs | : | nil | id | : | 25f6eb47-af82-44ff-bf7c-d3f327442c87 | eta | : | hline | taskset | : | hline | task | : | app.add | retries | : | 0 | utc | : | True | errbacks | : | hline | expires | : | hline |

** It isn't possible to change kombu JSON serializer
   kombu.utils.json dumps and loads are hardcoded into Channel._get
   and QoS.append methods discussed below.

** Acknowledgment implementation
   Celery store whole message in the queue list.  Then it take task id from
   message body and store it in the "unacked" redis hash against task
   id.

*** It is possible to take task from queue and don't save it in the unacked hash
    Channel.basic_get calls self.qos.append after self._get if no_ack
    is None.  _get uses rpop on its own.  Then self.qos.append calls
    pipeline with zadd with new message dump.

*** Here is redis state

    #+BEGIN_SRC fundamental
      >>> KEYS *
      1) "celery"
      2) "unacked"
      3) "_kombu.binding.celery.pidbox"
      4) "_kombu.binding.celery"
      5) "_kombu.binding.celeryev"
      6) "unacked_index"
      7) "unacked_mutex"
      >>> LRANGE celery 0 -1
      1) "{\"properties\": {\"delivery_tag\": \"13ce9ff2-c596-4471-84b6-94d3ef332041\", \"delivery_mode\": 2, \"correlation_id\": \"79bfa93e-c66b-4f45-b282-3b3835abcbad\", \"body_encoding\": \"base64\", \"delivery_info\": {\"priority\": 0, \"exchange\": \"celery\", \"routing_key\": \"celery\"}, \"reply_to\": \"ee172d34-d646-3478-9126-7df1d127e6fc\"}, \"body\": \"eyJ0aW1lbGltaXQiOiBbbnVsbCwgbnVsbF0sICJ0YXNrc2V0IjogbnVsbCwgInRhc2siOiAiYXBwLmFkZCIsICJleHBpcmVzIjogbnVsbCwgInJldHJpZXMiOiAwLCAidXRjIjogdHJ1ZSwgImNhbGxiYWNrcyI6IG51bGwsICJpZCI6ICI3OWJmYTkzZS1jNjZiLTRmNDUtYjI4Mi0zYjM4MzVhYmNiYWQiLCAiY2hvcmQiOiBudWxsLCAia3dhcmdzIjoge30sICJldGEiOiBudWxsLCAiYXJncyI6IFsxLCAyXSwgImVycmJhY2tzIjogbnVsbH0=\", \"headers\": {}, \"content-encoding\": \"utf-8\", \"content-type\": \"application/json\"}"
      >>> HGETALL unacked
      1) "13ce9ff2-c596-4471-84b6-94d3ef332041"
      2) "[{\"body\": \"eyJ0aW1lbGltaXQiOiBbbnVsbCwgbnVsbF0sICJ0YXNrc2V0IjogbnVsbCwgInRhc2siOiAiYXBwLmFkZCIsICJleHBpcmVzIjogbnVsbCwgInJldHJpZXMiOiAwLCAidXRjIjogdHJ1ZSwgImNhbGxiYWNrcyI6IG51bGwsICJpZCI6ICI3OWJmYTkzZS1jNjZiLTRmNDUtYjI4Mi0zYjM4MzVhYmNiYWQiLCAiY2hvcmQiOiBudWxsLCAia3dhcmdzIjoge30sICJldGEiOiBudWxsLCAiYXJncyI6IFsxLCAyXSwgImVycmJhY2tzIjogbnVsbH0=\", \"content-type\": \"application/json\", \"properties\": {\"body_encoding\": \"base64\", \"delivery_info\": {\"routing_key\": \"celery\", \"exchange\": \"celery\", \"priority\": 0}, \"reply_to\": \"ee172d34-d646-3478-9126-7df1d127e6fc\", \"delivery_mode\": 2, \"correlation_id\": \"79bfa93e-c66b-4f45-b282-3b3835abcbad\", \"delivery_tag\": \"13ce9ff2-c596-4471-84b6-94d3ef332041\"}, \"content-encoding\": \"utf-8\", \"headers\": {}}, \"celery\", \"celery\"]"
    #+END_SRC

*** Here is task message

    #+BEGIN_SRC json
      {
          "properties": {
              "delivery_tag": "13ce9ff2-c596-4471-84b6-94d3ef332041",
              "delivery_mode": 2,
              "correlation_id": "79bfa93e-c66b-4f45-b282-3b3835abcbad",
              "body_encoding": "base64",
              "delivery_info": {
                  "priority": 0,
                  "exchange": "celery",
                  "routing_key": "celery"
              },
              "reply_to": "ee172d34-d646-3478-9126-7df1d127e6fc"
          },
          "body": "eyJ0aW1lbGltaXQiOiBbbnVsbCwgbnVsbF0sICJ0YXNrc2V0IjogbnVsbCwgInRhc2siOiAiYXBwLmFkZCIsICJleHBpcmVzIjogbnVsbCwgInJldHJpZXMiOiAwLCAidXRjIjogdHJ1ZSwgImNhbGxiYWNrcyI6IG51bGwsICJpZCI6ICI3OWJmYTkzZS1jNjZiLTRmNDUtYjI4Mi0zYjM4MzVhYmNiYWQiLCAiY2hvcmQiOiBudWxsLCAia3dhcmdzIjoge30sICJldGEiOiBudWxsLCAiYXJncyI6IFsxLCAyXSwgImVycmJhY2tzIjogbnVsbH0=",
          "headers": {
          },
          "content-encoding": "utf-8",
          "content-type": "application\/json"
      }
    #+END_SRC

*** Here is task body

    #+BEGIN_SRC python :session Python
      import base64
      import json
      import pprint
      pprint.pprint(json.loads(base64.decodebytes(b'eyJ0aW1lbGltaXQiOiBbbnVsbCwgbnVsbF0sICJ0YXNrc2V0IjogbnVsbCwgInRhc2siOiAiYXBwLmFkZCIsICJleHBpcmVzIjogbnVsbCwgInJldHJpZXMiOiAwLCAidXRjIjogdHJ1ZSwgImNhbGxiYWNrcyI6IG51bGwsICJpZCI6ICI3OWJmYTkzZS1jNjZiLTRmNDUtYjI4Mi0zYjM4MzVhYmNiYWQiLCAiY2hvcmQiOiBudWxsLCAia3dhcmdzIjoge30sICJldGEiOiBudWxsLCAiYXJncyI6IFsxLCAyXSwgImVycmJhY2tzIjogbnVsbH0=').decode()))
    #+END_SRC

    #+RESULTS:
    : {'args': [1, 2],
    : 'callbacks': None,
    : 'chord': None,
    : 'errbacks': None,
    : 'eta': None,
    : 'expires': None,
    : 'id': '79bfa93e-c66b-4f45-b282-3b3835abcbad',
    : 'kwargs': {},
    : 'retries': 0,
    : 'task': 'app.add',
    : 'taskset': None,
    : 'timelimit': [None, None],
    : 'utc': True}

* Rabbit broker implementation

** It has payload property which contain whole dumped message

   #+BEGIN_SRC yaml
     args: [1, 2]
     callbacks: null
     chord: null
     errbacks: null
     eta: null
     expires: null
     id: 4bb5922d-3c7e-48ec-abca-7ad880ba9723
     kwargs: {}
     retries: 0
     task: app.add
     taskset: null
     timelimit: [null, null]
     utc: true
   #+END_SRC

   #+BEGIN_SRC json
     {
         "chord": null,
         "args": [
             1,
             2
         ],
         "id": "27ebcaee-444f-4379-a438-04c3b5bb0fc3",
         "eta": null,
         "utc": true,
         "errbacks": null,
         "timelimit": [
             null,
             null
         ],
         "kwargs": {
         },
         "taskset": null,
         "callbacks": null,
         "expires": null,
         "retries": 0,
         "task": "app.add"
     }
   #+END_SRC

** For pickle and msgpack it encoded into base64 strings

   #+BEGIN_SRC python :session Python
     import base64
     base64.decodebytes(b'gAJ9cQAoWAMAAAB1dGNxAYhYBwAAAHRhc2tzZXRxAk5YAgAAAGlkcQNYJAAAADFiODE2ODRmLWM4MzctNDZhYS04YzVlLTI2OTRlZTQzMzI3M3EEWAkAAAB0aW1lbGltaXRxBU5OhnEGWAMAAABldGFxB05YCAAAAGVycmJhY2tzcQhOWAkAAABjYWxsYmFja3NxCU5YBwAAAGV4cGlyZXNxCk5YBQAAAGNob3JkcQtOWAcAAAByZXRyaWVzcQxLAFgGAAAAa3dhcmdzcQ19cQ5YBAAAAHRhc2txD1gHAAAAYXBwLmFkZHEQWAQAAABhcmdzcRFLAUsChnESdS4=')
   #+END_SRC

   #+RESULTS:
   : b'\x80\x02}q\x00(X\x03\x00\x00\x00utcq\x01\x88X\x07\x00\x00\x00tasksetq\x02NX\x02\x00\x00\x00idq\x03X$\x00\x00\x001b81684f-c837-46aa-8c5e-2694ee433273q\x04X\t\x00\x00\x00timelimitq\x05NN\x86q\x06X\x03\x00\x00\x00etaq\x07NX\x08\x00\x00\x00errbacksq\x08NX\t\x00\x00\x00callbacksq\tNX\x07\x00\x00\x00expiresq\nNX\x05\x00\x00\x00chordq\x0bNX\x07\x00\x00\x00retriesq\x0cK\x00X\x06\x00\x00\x00kwargsq\r}q\x0eX\x04\x00\x00\x00taskq\x0fX\x07\x00\x00\x00app.addq\x10X\x04\x00\x00\x00argsq\x11K\x01K\x02\x86q\x12u.'

   #+BEGIN_SRC python :session Python
     import pickle
     pickle.loads(b'\x80\x02}q\x00(X\x03\x00\x00\x00utcq\x01\x88X\x07\x00\x00\x00tasksetq\x02NX\x02\x00\x00\x00idq\x03X$\x00\x00\x001b81684f-c837-46aa-8c5e-2694ee433273q\x04X\t\x00\x00\x00timelimitq\x05NN\x86q\x06X\x03\x00\x00\x00etaq\x07NX\x08\x00\x00\x00errbacksq\x08NX\t\x00\x00\x00callbacksq\tNX\x07\x00\x00\x00expiresq\nNX\x05\x00\x00\x00chordq\x0bNX\x07\x00\x00\x00retriesq\x0cK\x00X\x06\x00\x00\x00kwargsq\r}q\x0eX\x04\x00\x00\x00taskq\x0fX\x07\x00\x00\x00app.addq\x10X\x04\x00\x00\x00argsq\x11K\x01K\x02\x86q\x12u.')
   #+END_SRC

   #+RESULTS:
   | timelimit | : | (None None) | expires | : | hline | kwargs | : | nil | task | : | app.add | args | : | (1 2) | id | : | 1b81684f-c837-46aa-8c5e-2694ee433273 | retries | : | 0 | eta | : | hline | utc | : | True | callbacks | : | hline | chord | : | hline | errbacks | : | hline | taskset | : | hline |

   #+BEGIN_SRC python :session Python
     import base64
     base64.decodebytes(b'jaVjaG9yZMCkdGFza6dhcHAuYWRko2V0YcCiaWTZJGVmNGIxMDc4LTJmMzYtNGRlYS1iMDM0LWRiZWMyOWNmZmE3ZqRhcmdzkgECqGVycmJhY2tzwKZrd2FyZ3OAp3JldHJpZXMAp3Rhc2tzZXTAqWNhbGxiYWNrc8CpdGltZWxpbWl0ksDAo3V0Y8OnZXhwaXJlc8A=')
   #+END_SRC

   #+RESULTS:
   : b'\x8d\xa5chord\xc0\xa4task\xa7app.add\xa3eta\xc0\xa2id\xd9$ef4b1078-2f36-4dea-b034-dbec29cffa7f\xa4args\x92\x01\x02\xa8errbacks\xc0\xa6kwargs\x80\xa7retries\x00\xa7taskset\xc0\xa9callbacks\xc0\xa9timelimit\x92\xc0\xc0\xa3utc\xc3\xa7expires\xc0'

   #+BEGIN_SRC python :session Python
     import msgpack
     msgpack.loads(b'\x8d\xa5chord\xc0\xa4task\xa7app.add\xa3eta\xc0\xa2id\xd9$ef4b1078-2f36-4dea-b034-dbec29cffa7f\xa4args\x92\x01\x02\xa8errbacks\xc0\xa6kwargs\x80\xa7retries\x00\xa7taskset\xc0\xa9callbacks\xc0\xa9timelimit\x92\xc0\xc0\xa3utc\xc3\xa7expires\xc0')
   #+END_SRC

   #+RESULTS:
   | b | task | : | b | app.add | b | timelimit | : | (None None) | b | id | : | b | ef4b1078-2f36-4dea-b034-dbec29cffa7f | b | kwargs | : | nil | b | chord | : | hline | b | args | : | (1 2) | b | callbacks | : | hline | b | retries | : | 0 | b | errbacks | : | hline | b | expires | : | hline | b | eta | : | hline | b | taskset | : | hline | b | utc | : | True |

* Research questions

** How celery takes tasks from RabbitMQ broker?

** How celery takes tasks from Redis broker?

** How celery submits tasks into RabbitMQ broker?

** How celery submits tasks into Redis broker?

** How ETA tasks works in RabbitMQ broker?

** How ETA tasks works in Redis broker?

** How worker prefetch limit works?

** How *in worker* task distribution on cores works?

** Why message priority in queue *doesn't* works in RabbitMQ broker?

** How message priority in queue *does* works in Redis broker?

** How rate limit works in the celery worker?
   Looks like rabbitmq worker takes all messages and defer accepted
   tasks if rate limit already passed.

** How much does it costs to submit task with blocking io from asynchronous web handler?

** What information celery stores in broker and backend?
   - if backend enabled
   - if backend disabled
   - how this information changes in the case of links, groups and chords

** How control commands works in celery?

** Does celery supports RabbitMQ clusterization?

** Does Redis broker supports clusterization?

** Does Redis backends supports clusterization?
   - Maybe it called sharding in this case.

** How celery implements cancelation of already running tasks?

** How task retry works in celery?

* Implementation required

** ETA in the RQ

** Groups, chords in the RQ

** Finish aiorq

** Redis bluster RQ version

* Ideas

** Rabbit doesn't come easy slide
   Slide with Hellowin album cover scan
