* Очереди задач без купюр
  Всем привет, меня зовут Малышев Артем.  Я работаю компании Positive
  Technologies и сегодня расскажу вам про очереди задач.  В прошлом
  году во время доклада на этуже тему тут весь зал поднял руки,
  отвечая на вопрос "А кто вообще знает, что это такое?"  Поэтому я
  осмелюсь предположить что большая часть аудитории с обсуждаемой
  темой знакома.  Что характерно на вопрос "Кто считает что это
  плохо?" рук подняли ещё больше.  Так почему же без купюр?  Неточтобы
  я тут собрался материться.  Просто хочется раскрыть вам эту тему
  немного с другой стороны.  Поговорим о том как и почему очереди
  задач устроены.  Прежде всего хочу предупредить, никакого рассказа
  про серебрянные пули не будет.  Я не обвиняю и не оправдываю ни один
  из выбранных подходов.  Я просто расскажу вам как обстоят дела, а
  дальше вы сами решите как будете с этим жить.

* Celery
  (Фотка @ask и логотип Celery), стары на гитхабе, скачивания на PyPY)
  Итак главный гость нашей программы - Celery.  Распределённая очередь
  задач, написанная Аском Солемом Хоуэлом.  Умеет использовать всё до
  чего дотянется и как брокер и как бэкэнд.  Имеет непревзойдённое
  колличество фич.  Думаю все с этой штукой знакомы и очень многие
  используют в продакшене.  Все обсуждаемые вопросы я буду
  рассматривать с точки зрения rabbitmq и redis (и как брокер и как
  бэкэнд).

* RQ
  (Фотка @nvie и логотип RQ, стары на гитхабе, скачивания на PyPY) В
  левом углу ринга RQ, он же Redis Queue.  Наиболее популярная
  альтернатива Celery.  Автор RQ поначалу что-то контрибъютил в
  Celery, но потом видимо потерял надежду и написал свой пакет.  Он в
  отличие о Celery умеет только в redis.  Основывается на простой
  архитектуре и хороших намерениях, ну и позиционирует этот подход как
  преимущество над апонентом.  И так, прежде чем рассматривать как
  очереди задач используют свои брокеры и бэкэнды - обсудим, а что эти
  средства вообще умеют.

* rabbitmq
  (Картинка с exchange with queue) RabbitMQ брокер сообщений
  работающий по протоколу AMQP.  Девиз проекта "Messaging that just
  works".  Основные приметивы - очереди, exchange'и и биндинги одного
  к другому.  Если мы выступаем в роли publisher'а - мы можем
  отправить сообщение в exchange и он тут же положет его в очередь.
  Как именно он это сделает - зависит от типа самого exchange и от
  биндингов, которые существуют между ним и очередями.  У самого
  rabbitmq есть механизм контроля особо активных паблишеров.  Он может
  сказать одному из них: "Помолчи."  И до тех пор пока rabbitmq не
  скажет тому же паблишеру: "Продолжай", каждый порядочный паблишер
  будет молчать.

* on the other side
  Если же мы выступаем в роли консьюмера, то от нас уже мало что
  зависит.  RabbitMQ сам решает когда и как он будет назначать на нас
  сообщения.  Консъюмер в свою очередь обязается подтверждать
  получение сообщения только в том случае, если он смог успешно его
  обработать.  При этом значение слова "успешно" трактуется
  исключительно самим консьюмером и его пользователем.  Как только
  rabbitmq получил acknowledge по сообщению - он волен его удалить.
  У самого консьюмера имеется механихм обратной связи с rabbitmq - так
  называемый Quality of Service.  Это механизм, через который
  консьюмер может сообщить кролику сколько сумарно неподтверждённых
  сообщений он может иметь.  Как только это количество стало равно
  пороговому rabbitmq перестаёт назначать сообщения, до тех пор пока
  не придёт acknowledge хотябы на одно сообщение.

* amqp
  Теперь немного более детально про сам протокол общения между
  клиентами и rabbit'ом.  У нас в руках асинхронный протокол с
  поддержкой мультиплексирования.  Минимально возможной
  последовательностью байт является фрейм.  Это оформленный пакет,
  который несёт в себе метод, который необходимо применить к очереди,
  эксченджу или биндингу.  Это может быть фрейм с контентом, который
  необходимо доставить другому клиенту.  Или же это может быть
  heartbeet фрэйм для проверки активности соединения.  Ну и чтобы
  фаервол не смущать.  Логическая последовательность фреймов
  называется каналом.  Канал является примитивом мультиплексирования и
  позволяет обрабатывать несколько виртуальный соединений в рамках
  одного физического.  Последовательность фреймов в сокете можем быть
  произвольная, но в рамках канала строго определённая.  Результат
  операции запущенной позже другой может придти раньше.

* redis
  (логотип и фотка @antires)  Redis в свою очередь к очередям
  сообщений отнощение имеет только косвенное, но это судя по всему
  никого не останавливает.  Редиска является key value хранилищем.
  Хранимые значения могут быть самые разные.  Чиселки, строки, словари
  и списки.  Вот из таких приметивов и строится нечто похожее на
  брокер сообщений.  Протокол общения рэдиса с клиентами самый
  простой - записали команду, прочитали ответ.  Пока команда не
  выполнилась - ничего другого ждать не стоит.  Сами команды в рэдис
  слать можно хоть через telnet.

* submit a task
  (две строчки кода с task.delay и queue.enqueue)  Двайте посмотрим
  как в очереди задач эти самые очереди попадают.

* celery + rabbitmq
  (скриншот из rabbitmq manager) В случае с rabbitmq и celery всё
  просто - в брокер в соответствие с celery routing попадает
  сообщение.  В payload фрэймах приходит необходимая информация - id
  задачи, какую задачу с какими аргументами запустить, что делать с
  результатом дальше.  Информация необходимая брокеру храниться в AMQP
  заголовках.

* celery + redis
  (lrange по очереди) Celery собирает сообщение которое также состоит из служебной
  информации и поля payload.  Формат самого сообщения - всегда JSON,
  формат в котором мы хотим хранить payload можно выбрать по своему
  усмотрению.  Сфорированное сообщение в виде строки попадает в список
  соответствующий названию очереди.

* rq
  (lrange по очереди, hgetall по задаче)  RQ в данном случае ведёт
  себя похожим образом.  В список соответствующий очереди попадает
  id задачи.  По ключу с id задачи храниться хэшь таблица с полями
  самой задачи.  Какую функцию с какими аргументами вызвать.  Когда
  задача была создана, запланирована и так далее.  Отличительной
  особенностью здесь является что celery может получить всю задачу
  сразу, т.к. нет необходимости отдельно получать id задачи и отдельно
  саму задачу.

* получение задач
  (две команды стартовать воркер)  Что же происходит с задачей, когда
  она попадает в сам воркер?  Здесь как и следовало ожидать тоже
  имеется существенная разница в поведении.

* celery + rabbit
  (скрин с ready, unacked и total) В зависимости от настройки
  CELERY_ACKS_LATE после того как сообщение было доставлено
  консьюмеру, воркер может подтвердить сообщение сразу или только по
  окончанию выполнения задачи.

* celery + redis
  Как только Celery забрала элемент из списка - задача полностью
  пропадает из очереди.  Воркер разбирает сообщение, достаёт task.id
  из поля payload и снова сохраняет всю задачу в хэшэ "unacked" по
  ключу соответствующему номеру задачи.  Далее воркер начинает
  обработку задачи.  По окончанию ключ с задачей удаляется из хэша.

* rq
  Как только id задачи был получен воркером он пропадает из очереди и
  помещается в started job registry.  Это сортированное множество
  хранящее в себе id'шники стартованных задач и таймстэмпы,
  позволяющие нам судить о времени выполнения.  Как мы видим у RQ
  отсутствует необходимость второй раз пересылать тело задачи в брокер
  целеком, т.к. id храниться отдельн от тела.

* Первый подводный камень
  (скрин вершина айсберга) Сам перенос в обоих случаях выполняется
  неатомарно в две операции.  Если в момент между получением задачи и
  сохранением её во временное хранилище у воркера пропала связь с
  redis'ом - задача может уйти в никуда и оставить кластер в
  неконсистентном состоянии.  Такая реализация acknowledgements не
  настоящая и защищает только от сбоев вида "успели сохранить, а
  умерло всё уже потом".

* Как могло бы быть
  (На айсберге появляются два пункта rpoplpush и lua scripts)
  Использование списков редиса в виде транспорта сообщений вообще
  является очень распространённой практикой.  Судя по всему очень
  распространено и хождение по выше указанным граблям.  rpoplpush
  операция которая выполняет перенос сообщения во временное хранилище
  на сервере и только потом отдаёт сам мессадж воркеру.  Грабли
  настолько распространённые, что в документации редиса у этой команды
  есть пометка специально для разработчиков очередей задач.  Минус у
  данного подхода только один - можно работать одновременно только с
  одной очередью.  Альтернатива - забирать задачи из редиса с помощью
  lua скриптов, выполняемых на сервере.  Привет хранимки.  По сути
  можно эмулировать rpoplpush для нескольких очередей.  Так что, если
  вам на текущий момент нужен железный acknowledge - берите rabbitmq.
